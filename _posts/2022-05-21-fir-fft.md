---
title: 'FFT-based FIR filtering using overlap-add method'
date: 2022-06-21 22:00:00
categories: [DSP essentials]
tags: [dsp, fft, fir, overlap-add, matlab]
math: true
# mermaid: true
---

You have a very long signal, and you want to filter it with an FIR filter.
The signal can be a stream of radio or audio, and you are going to implement it on a resource-constrained device, an FPGA or an MCU.
This looks like a simple task for newbies, what could be wrong?

## The Memory is Limited

A common mistake beginners make is loading the entire signal to the memory and then filtering it.
This could work in Matlab, but there are many issues when implementing it on real hardware.
First, the signal can be very long, and the memory (or registers in an FPGA) is limited.
The memory is precious, and you don't want to eat it all up and crash your device.

Second, it is a waste of time if you start the filtering until the end of the signal stream.
The normal way to do it is once a block of the signal is ready, you filter it, and then you wait for the next block.
It can be considered a producer-consumer problem, and there are standard implimentations in each language.

## Overlap-Add Method

We know that the DFT provides an efficient way to compute the convolution (or linear filtering) of two signals in the frequency domain (go back to any DSP textbook if you don't know about it).
To filter a very long sequence, two DFT-based approaches are the overlap-add method and the overlap-save method.
Both of them break the signal into blocks and then compute the convolution of each block independently, and then combine the results in a certain way.
We will only discuss the overlap-add method here and focus on the implementation in Matlab.

```matlab
function y = fft_filter(b,x)
    %   Overlap-add method for FIR filtering using FFT.
    %   Y = FFTFILT(B,X) filters X, with the FIR filter specified by the vector
    %   of coefficients B, using the overlap/add method, and internal
    %   parameters (FFT size and block length) that guarantee efficient
    %   execution.
    
    %
    %   It is advantageous to use FFTFILT instead of FILTER when the signal is
    %   relatively large.  FILTER performs N multiplications for each sample in
    %   X where N is the filter length.  FFTFILT performs 2 FFT operations at
    %   the cost of L*log2(L)/2 where L is the block length.  It then performs
    %   L pointwise multiplications for a total cost of L*(1+log2(L))
    %   multiplications.  The cost ratio is therefore L*(1+log2(L))/(N*L) =>
    %   (1+log2(L))/N which is approximately log2(L)/N.  Therefore FFTFILT
    %   becomes advantageous when log2(L) is less than N.
    %
    %   % Example 1:
    %   %   Construct a Signal and filter it with a 10 point averaging filter
    %   %   using fftfilt.
    %
    %   fs = 100;                               % Sampling frequency
    %   t = 0:1/fs:1;                           % Time vector
    %   x = sin(2*pi*t*3)+.25*sin(2*pi*t*40);   % Input Signal
    %   b = ones(1,10)/10;  % 10 point averaging filter
    %   y = fftfilt(b,x);   % FIR filtering using overlap-add method
    %   plot(t,x,t,y,'--');
    %   legend('Original Signal','Filtered Signal')
    %
    %   % Example 2:
    %   %   Use the designfilt function to design a lowpass FIR digital filter
    %   %   with order 350 and cutoff frequency of 150 Hz. The sample rate is
    %   %   1.5 KHz. Filter a long vector of data using the overlap-add method
    %   %   to increase speed.
    %
    %   D = designfilt('lowpassfir', 'FilterOrder', 350, ...
    %    'CutoffFrequency', 150, 'SampleRate', 1500);
    %
    %   data = randn(10e6,1);
    %   y = fftfilt(D,data);
    %
    %   See also FILTER, FILTFILT.
    
    %   --- Algorithmic details ---
    %   The overlap/add algorithm convolves B with blocks of X, and adds
    %   the overlapping output blocks.  It uses the FFT to compute the
    %   convolution.
    %
    %   Particularly for long FIR filters and long signals, this algorithm is
    %   MUCH faster than the equivalent numeric function FILTER(B,1,X).
    %
    %   Y = FFTFILT(B,X) -- If you leave N unspecified:   (RECOMMENDED)
    %       Usually, length(X) > length(B).  Here, FFTFILT chooses an FFT
    %       length (N) and block length (L) which minimize the number of
    %       flops required for a length-N FFT times the number of blocks
    %       ceil(length(X)/L).
    %       If length(X) <= length(B), FFTFILT uses a single FFT of length
    %       nfft = 2^nextpow2(length(B)+length(X)-1), essentially computing
    %       ifft(fft(B,nfft).*fft(X,nfft)).
    %
    %   Y = FFTFILT(B,X,N) -- If you specify N:
    %       In this case, N must be at least length(B); if it isn't, FFTFILT
    %       sets N to length(B).  Then, FFTFILT uses an FFT of length
    %       nfft = 2^nextpow2(N), and block length L = nfft - length(B) + 1.
    %       CAUTION: this can be VERY inefficient, if L ends up being small.
    

    % Check validity of input
    validateattributes(b,{'double'},{'column'},'fft_filter','B',1);
    validateattributes(x,{'double'},{'column'},'fft_filter','X',2);

    % count the number of element for x and b
        nx = size(x,1);
        nb = size(b,1);

    % determine the most efficient NFFT
    if nb >= nx || nb > 2^20              % take a single FFT in this case
        nfft = 2^nextpow2(nb + nx -1);    % 2^ceil(log2(nb + nx -1))
        L = nx;
    else
        fftflops = [ 18 59 138 303 660 1441 3150 6875 14952 32373 69762 ...
            149647 319644 680105 1441974 3047619 6422736 13500637 28311786 ...
            59244791 59244791*2.09];
        n = 2.^(1:21);
        nValid = n(n > nb-1);
        fftflopsValid = fftflops(n > nb-1);
        % minimize (number of blocks) * (number of flops per fft)
        L1 = nValid - (nb - 1);
        [~,ind] = min(ceil(nx./L1).*fftflopsValid);
        nfft = nValid(ind);               % must have nfft > (nb-1)
        L = L1(ind);
    end
    
    B = fft(b,nfft,1);
    % init output y
    y = zeros(size(x),'like',1+1i);
    istart = 1;
    while istart <= nx
        iend = min(istart+L-1,nx);
        X = fft(x(istart:iend,:),nfft,1);
        yblock = ifft(X.*B,[],1);
        yend = min(nx,istart+nfft-1);
        y(istart:yend,:) = y(istart:yend,:) + yblock(1:(yend-istart+1),:);
        istart = istart + L;
    end
    
    if ~(any(imag(b),'all') || any(imag(x),'all'))
        y = real(y);
    end
    

end
```
